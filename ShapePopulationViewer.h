#ifndef SHAPEPOPULATIONVIEWER_H
#define SHAPEPOPULATIONVIEWER_H

#include <QMainWindow>
#include "ui_ShapePopulationViewer.h"
#include <QDir>
#include <QVector>
#include "QVTKWidget.h"
#include "vtkPolyData.h"
#include "vtkPolyDataMapper.h"
#include "vtkScalarBarActor.h"
#include <QResizeEvent>
#include <QEvent>
#include <QSize>
#include <QString>

/**
 * ShapePopulationViewer Gui class specification.  This class contains all model data and controller callbacks, if we are going to consider the code within the MVC paradigm.  See
 * ui_ShapePopulationViewer.h for information on the construction of the gui itself.  It is an autogenerated file from the ShapePopulationViewer.ui file, which could also be used as reference.
 *
 * Generally speaking there are two classes of functionality given by the code, viewing options and filesystem interaction.  The filesystem interaction is supported by callbacks which an both read and write meshes to .vtk
 * formatted files.  The viewing option functionality includes the propogation of renderer interaction between QVTKWidgets, the ability to rearrange the QVTKWidgets in a user specified number of columns, and the ability to
 * change the colormap used to view the meshes, ranging over any colormap present in the .vtk file originally.
 *
 * @brief The ShapePopulationViewer class
 * @author Michael Guarino
 */
class ShapePopulationViewer : public QMainWindow, public Ui::ShapePopulationViewer
{
  Q_OBJECT
public:
  // Constructor/Destructor
  ShapePopulationViewer();
  ~ShapePopulationViewer() {}
public slots:

  virtual void slotExit();

protected:
   void ModifiedHandler();
   void resizeEvent(QResizeEvent* event);
   /**
    * Bit which represents if the meshes will propogate events upon a modification
    * @brief synced
    */
   bool synced;
   /**
    * The user selected working directory
    * @brief directory
    */
   QDir directory;
   /**
    * Vector of QVTKWidgets maintained to generate render callbacks, and for removal from the scrollarea
    * For the removal to be visualized, one must remove them from memory entirely
    * @brief widgetList
    */
   QVector<QVTKWidget *> *widgetList;
   /**
    * Vector of vtkPolyData, which is maintained for the purpose of writing back the polydata to secondary storage primarily
    * @brief polyList
    */
   QVector<vtkPolyData *> *polyList;
   /**
    * Vector of vtkPolyDataMapper's, maintained to make colormap updates easier.
    * @brief mapperList
    */
   QVector<vtkPolyDataMapper *> *mapperList;
   /**
    *
    * @brief colorMaps
    */
   QSize scrollAreaSize;
   /**
    * Name of the working colormap
    * @brief cmap
    */
   QString cmap;

   //these are all trivial maintenance data
   int prevCols;
   int prevRows;
   int phi;
   int loaded;
   void updateWidgets();
   void updateCMaps();
protected slots:
   void on_checkBox_9_toggled(bool checked);
   void flipMeshes();
   void writeMeshes();
   void openVTKS();
   void on_checkBox_10_toggled(bool checked);
   void on_lineEdit_editingFinished();
   void on_checkBox_3_toggled(bool checked);
   void on_comboBox_currentIndexChanged(const QString &arg1);
   void on_toolButton_clicked();
   void on_toolButton_2_clicked();
   void on_toolButton_3_clicked();
   void on_toolButton_4_clicked();
   void on_toolButton_5_clicked();
   void on_toolButton_6_clicked();
   void viewChange(int x, int y, int z);
};

#endif
